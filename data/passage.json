{
  "code": 0,
  "data": {
    "records": [
      {
        "id": "1629504302449963010",
        "title": "快速通过软考",
        "description": "如何快速通过软件设计师的考试",
        "content": "\n![f8af55a9c0104edd85bfb0988b70511.jpg](https://pic.code-nav.cn/post_picture/1612112775822180354/gSmF2r0p-f8af55a9c0104edd85bfb0988b70511.jpg)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2ed16e5b7ad74d439fde93802c836a91.png#pic_center)\n\n# 什么是软考？\n\n软考全称“计算机技术与软件专业技术资格（水平）考试”，由国家人力资源和社会保障部、工业和信息化部领 导下的国家级考试，设置了27个资格包括初级、中级、高级三个级别。官网地址如下：\n\n<https://www.ruankao.org.cn/>\n\n# 软考的含金量与意义\n\n1.  软考证书每月都有补贴，不仅国企和事业单位，甚至普通公司也会补贴。并且获取软考证书可以补税退税。\n2.  软考是国家级考试。通过软考中高级考试，就是国家认定的中高级技术人员。国家很多政策优惠在计算机领域只认软考。而国外的那些证书（OCP数据库认证、思科认证）是不能享受优惠政策的。软考能够积分落户、退休金补贴、个税补贴、申请廉租房......。。软考证书可以抵扣个税，大概可以少交1500元的个人所得税。\n3.  软考的知识点覆盖面十分广泛，基本会设计到软件开发的所有需要掌握的理论知识，比如设计模式、\n\n    软件工程、数据库、计算机网络、操作系统、计算机组成原理等计算机科班所必须学习的知识，因此非常适合了解该专业的一个系统的框架以及深入理解一些理论知识。\n\n# 正常备考节奏\n\n# 备考时长\n\n首先去官网买一本你所要考的等级的官方用书，我这边就以我通过的中级软件设计师来举例了，然后再购买近五年的上下班年的真题试卷结合着下面up主的视频来学习，大概需要三个月的时长。\n\n## 学习路线\n\n推荐一个up主的视频，非常细致且好理解，如果能完完整整地跟着学完一定能够高分通过！！\n\n<https://www.bilibili.com/read/cv18526892>\n\n\n## 推荐笔记\n[笔记](<https://blog.csdn.net/apple_53947466/article/details/125557473?app_version=5.7.3&csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22125557473%22%2C%22source%22%3A%22apple_53947466%22%7D&utm_source=app>)\n\n## 高频考点\n [考点1](<https://blog.csdn.net/m0_64128218/article/details/127291829?app_version=5.9.0&code=app_1562916241&csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22127291829%22%2C%22source%22%3A%22m0_64128218%22%7D&uLinkId=usr1mkqgl919blen&utm_source=app>)\n \n[考点2](<https://blog.csdn.net/m0_64128218/article/details/127289970?app_version=5.9.0&code=app_1562916241&csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22127289970%22%2C%22source%22%3A%22m0_64128218%22%7D&uLinkId=usr1mkqgl919blen&utm_source=app>)\n\n\n# 重要考点\n\n自己从刷的题中总结出来的知识点。你们遇到了自然就能懂是什么意思了，对照着知识点去回忆知识是一种很高效的查漏补缺的办法。\n\n-   寻址方式\n-   总线\n-   流水线\n-   中断（DMA）\n-   存储器（RAM flesh cache）\n-   原码、补码、阶码\n-   防火墙  网络安全知识\n-   加密算法（公开，私有（共享）） 非对称\n-   软著、商业秘密、著作权\n-   数据流图\n-   软件设计原则\n-   风险检测\n-   活动图\n-   符号表、决策表、广义表\n-   有限自动机\n-   进程状态\n-   页面管理 &#x20;\n-   PV图\n-   死锁算法公式\n-   磁盘旋转算法\n-   增量模型、瀑布模型、螺旋模型\n-   统一过程up\n-   敏捷开发的五个原则\n-   ISO IEC 9126软件质量模型的六个特性\n-   系统测试\n-   系统分析\n-   概要设计、详细设计\n-   系统文档—用户与系统分析人员\n-   白盒测试—语句覆盖\n-   系统的可维护性\n-   软件评审\n-   面向对象分析步骤、设计原则\n-   UML关系：关联关系  UML各种图：状态图\n-   设计模式：中介者、策略\n-   数据库：三种模式、特殊符号含义\n-   栈、循环队列、双端队列、各种二叉树特性和公式、拓扑排序、哈夫曼树\n-   各种排序（归并、快速）的时空复杂度表、稳定性\n-   路由、ARP、网关\n-   编译程序的各种分析\n-   耦合的各种类型  内聚类型\n\n# 个人经验\n\n我开始准备软件设计师考试的时候其实距离考试时间仅仅一周多了，虽然最后考的分不高，但是也是稳稳地通过拿证了。那么如何在一周内完整突击呢？必须把仅五年的真题你所能掌握的每一道题做上三遍，**第一遍是闭卷写题，第二遍是对照着答案以及知识点笔记去记忆，第三遍是看错题**，注意上午是考选择题的，你做的题越多，出现原题的可能性就越大，考的基本都是类似的知识点，不需要去做一些额外的模拟题。而下午题是大题，考法非常的固定，算法题不会的话可以直接放弃，因为其他几道题做好已经能保证你高分通过了。考前就带着你的错题集或者试卷集去看，加深映象会发现考试的时候基本都是你碰到过得题型。\n\n最后大家如果需要我写的笔记或者有问题咨询的话可以在评论区留言！祝大家考出好成绩！！&#x20;",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1612112775822180354/29bfkZ4n-微信图片_20230225233105.jpg",
        "language": null,
        "viewNum": 160,
        "thumbNum": 19,
        "favourNum": 19,
        "commentNum": 5,
        "priority": 999,
        "userId": "1612112775822180354",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-02-25T15:31:15.000+00:00",
        "updateTime": "2023-03-12T11:50:48.000+00:00",
        "user": {
          "id": "1612112775822180354",
          "planetCode": "4838",
          "userName": "迷。",
          "userAvatar": "https://thirdwx.qlogo.cn/mmopen/vi_32/vialKcxTib4GfndTME6AqsmGedeZrOGuOOXEZDibdk7csQUXZaXe8jXRr8mTQrCj049AGz48ZCRL7rIjvNicmEKo9A/132",
          "gender": 1,
          "userProfile": "[加入编程导航](https://yupi.icu) 深耕编程提升【两年半】、国内净值【最高】的编程社群、用心服务【20000+】求学者、帮你自学编程【不走弯路】",
          "userRole": "vip",
          "interests": [],
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": null,
          "direction": "后端",
          "goal": "校招",
          "github": null,
          "blog": null,
          "score": 30,
          "coin": 170,
          "followeeNum": 2,
          "followNum": 1,
          "followStatus": null,
          "vipExpireTime": "2024-02-01T01:02:21.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-01-08T15:43:32.000+00:00",
          "updateTime": "2023-03-11T03:42:07.000+00:00"
        },
        "tags": [
          "文章",
          "软考"
        ],
        "fileList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": true,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1628948649796993025",
        "title": "Git使用指南",
        "description": "从入门到实践，轻松学会Git！",
        "content": "### 1、了解Git的基本概念\n\n在学习Git之前，需要了解Git的基本概念。下面是一些术语：\n\n- 仓库（`Repository`）：Git用仓库来存储代码，仓库可以保存所有的版本历史记录。\n- 分支（`Branch`）：分支是Git中一个重要的概念。通过创建分支，你可以在代码的不同版本之间切换。\n- 提交（`Commit`）：在Git中，每次对代码进行的更改都需要提交。提交可以记录下当前代码的状态，并保存在Git的历史记录中。\n- 合并（`Merge`）：在Git中，你可以合并不同的分支，将它们合并成一个版本。\n- 远程仓库（`Remote Repository`）：远程仓库是指存储在其他计算机或服务器上的Git仓库。你可以通过Git与远程仓库进行交互，例如推送代码、拉取代码等。\n\n### 2、安装Git\n\n在学习Git之前，需要先安装Git。Git可以在`Windows`、`Linux`和`MacOS`等操作系统上运行。可以通过以下链接下载Git并安装：\n\n- Windows: https://git-scm.com/download/win\n- MacOS: https://git-scm.com/download/mac\n- Linux: https://git-scm.com/download/linux\n\n安装完成后，可以在命令行中输入`git --version`来检查Git是否安装成功。\n\n### 3、学习Git的命令行界面\n\nGit可以通过命令行界面进行交互。下面是一些常用的Git命令：\n\n- `git init`：初始化一个新的Git仓库。\n- `git add <file>`：将一个文件添加到Git的暂存区。\n- `git commit -m \"<message>\"`：将暂存区的文件提交到Git仓库，并附带一条提交信息。\n- `git push`：将本地仓库中的代码推送到远程仓库。\n- `git pull`：从远程仓库拉取最新的代码到本地仓库。\n- `git status`：查看当前仓库的状态，包括哪些文件已修改、哪些文件已经添加到暂存区等等。\n- `git log`：查看提交历史记录。\n\n### 4、使用Git的可视化界面工具\n\n除了命令行界面，Git还提供了一些可视化界面工具，如`GitHub Desktop`、`GitKraken`等等。这些工具可以帮助你更方便地使用Git，特别是对于初学者来说。可以在它们的官方网站上下载并安装，然后使用它们来管理你的Git仓库。\n\n### 5、练习Git的使用\n\n最好的学习方法就是实践。可以创建一个Git仓库，尝试添加文件、提交变更、合并分支等等，来熟悉Git的使用。在实践中，可以先创建一个本地仓库，然后尝试使用Git命令行界面或者可视化界面工具对仓库进行管理。下面是一些练习的建议：\n\n- 创建一个新的仓库，并将代码添加到仓库中。\n- 创建一个新的分支，并在分支中进行代码修改。\n- 将修改后的分支合并到主分支中。\n- 将代码推送到远程仓库中。\n\n此外，还可以参与开源项目，学习如何与其他开发者协作使用Git。GitHub是一个非常流行的开源代码托管平台，可以在上面找到许多有趣的项目来学习和参与。\n\n**总结：** 学习Git需要花费一定的时间和精力，但它是现代软件开发不可或缺的工具。通过不断的练习和实践，逐渐熟悉Git的使用，并在软件开发中发挥重要的作用。\n\nGit已经成为前端入门必须掌握的技能，从HTML阶段到网页布局项目实战都需要用到。",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1627640946936008705/qahY9UXU-WeWf2Yis-image.png",
        "language": null,
        "viewNum": 211,
        "thumbNum": 14,
        "favourNum": 6,
        "commentNum": 2,
        "priority": 0,
        "userId": "1627640946936008705",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-02-24T02:43:17.000+00:00",
        "updateTime": "2023-03-12T12:15:12.000+00:00",
        "user": {
          "id": "1627640946936008705",
          "planetCode": "10478",
          "userName": "一",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1627640946936008705/7vDU9uxb-af2aea18-6152-44c5-ab03-e247c8a6af1d.jpg",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": [],
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": null,
          "direction": null,
          "goal": null,
          "github": null,
          "blog": null,
          "score": 35,
          "coin": 20,
          "followeeNum": 5,
          "followNum": 5,
          "followStatus": null,
          "vipExpireTime": "2024-02-20T22:34:40.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-02-20T12:06:56.000+00:00",
          "updateTime": "2023-03-11T02:31:03.000+00:00"
        },
        "tags": [
          "文章",
          "前端",
          "工具",
          "教程"
        ],
        "fileList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": true,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1628338827426869249",
        "title": "编程导航建议反馈",
        "description": "本帖用于收集鱼友们对本站的建议和反馈，欢迎来戳~",
        "content": "欢迎朋友们在评论区分享对网站的看法和建议、指出网站的 Bug 和不足、给我们提需求加功能等等。。。\n\n我们会精选部分有价值的反馈和建议（被精选可以获得积分奖励），努力持续改进，争取给大家提供更好的服务和体验。谢谢大家！",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1601072287388278786/HEeCzAaz-006APoFYly1gf114exyufj30b408cmy0.jpg",
        "language": null,
        "viewNum": 270,
        "thumbNum": 14,
        "favourNum": 2,
        "commentNum": 34,
        "priority": 0,
        "userId": "1601072287388278786",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-02-22T10:20:04.000+00:00",
        "updateTime": "2023-03-12T09:19:01.000+00:00",
        "user": {
          "id": "1601072287388278786",
          "planetCode": "1",
          "userName": "程序员鱼皮",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1601072287388278786/9vqTr3HM-WechatIMG1287.jpeg",
          "gender": 1,
          "userProfile": "这个网站的老大",
          "userRole": "admin",
          "interests": [
            "C++",
            "Java",
            "Python",
            "算法"
          ],
          "place": "上海",
          "birthday": "1998-11-03",
          "school": "东华大学",
          "major": "网络工程",
          "education": null,
          "graduationYear": 2020,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": 2,
          "direction": "后端",
          "goal": null,
          "github": "https://github.com/liyupi",
          "blog": "https://yupi.icu",
          "score": 410,
          "coin": 170,
          "followeeNum": 260,
          "followNum": 5,
          "followStatus": null,
          "vipExpireTime": "2025-12-13T05:00:02.000+00:00",
          "lastLoginTime": null,
          "createTime": "2022-12-09T04:32:33.000+00:00",
          "updateTime": "2023-03-12T07:37:00.000+00:00"
        },
        "tags": [
          "文章"
        ],
        "fileList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": true,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1627985464722059265",
        "title": "chatGPT大火，来看看chatGPT的创始人对于程序员成功的分享",
        "description": "chatGPT之父在2019年博客上分享的文章《how to be successful》",
        "content": "## 《程序员的成功之路》\n> - 如果你觉得文字读起来太累：https://www.bilibili.com/video/BV1bs4y1a7B7/?spm_id_from=333.337.search-card.all.click&vd_source=ce628a5bd43df277d141676215ef5ff3\n> - 如果你想阅读英文原文：http://blog.samaltman.com/how-to-be-successful\n\n### 1.选择复利增长\n复利具有神奇的魔力，现在处处都在强调复利，这其中的奥秘就是指数曲线，因为指数曲线是创造财富的关键。一家中型企业的价值如果按照每年50%的速度增长，那么它的规模可以在短时间内极速扩张。世界上少有企业具有真正的网络效应和高度的可扩展性，但是随着技术进步，这种情况会逐渐改变，这值得我们不断为之努力。\n\n对个体的人生道路来说，我们也应该走成一条指数曲线。也就是说，我们要遵循不断向右增长的人生轨迹。在进行职业规划时，要选择具有复合效应的职业，而大多数职业的发展轨迹都是一条线性直线。\n\n在线性职业领域，工作二十年的效率并不会比工作两年的效率高，像这样的职业不利于个人发展。\n\n我们需要的是一份能保持不断学习的职业。随着职业发展，我们需要产出越来越多的成果。达成这一目标的途径多种多样，比如说资本、技术、品牌、网络效应和做管理。\n\n专注于将你所定义的成功指标增加十倍是有用的，这些指标可以是赚钱、社会地位、世界级影响力或者其他东西。我乐意接受挑战，愿意在各种项目上花时间以解锁下一个项目。但是我希望在每一个项目上都能取得最大成就，创造职业生涯新高度。但是大多数人都被困于线性发展的泥潭，往往捡了芝麻丢了西瓜，我们要学会抓大放小，寻求跳跃式提升。\n\n在我看来，无论是企业还是个人，最大的竞争优势就是要把目标放长远。我们要打开眼界，看出世界上不同体系之间交融互动的方式。复合增长最重要的就是眼光要尽可能放长远，这样的人才能抢占市场先机，获得最大回报。\n\n要相信指数曲线，耐心坚持下去，最后一定会有惊喜。\n\n### 2.要有绝对自信\n自信拥有不可思议的力量，就我认识的人来说，最成功的往往都是那些自信到离谱的人。\n\n我们要尽早树立自信。如果你的判断常常都很准确，能带来很好的结果，那么你一定要加倍自信。\n\n对自己不自信的人很难对未来抱有逆向思维，但是往往逆向思维才能创造出最大的价值。还记得很多年前马斯克带我参观SpaceX工厂，他详细地谈到了制造火箭的一些细节，但是让我印象最深的还是马斯克谈到向火星发射火箭时的表情，离开工厂时我就在想 “啊，这就是自信的样子”。\n\n对大多数创业者来说，激发自己以及团队的士气可以说是最大的挑战之一，如果没有自信，这就成了几乎不可能完成的任务。但往往一个人越有雄心壮志，其受到的打击就会越多。大多数非常成功的人在面对人们的质疑时至少有一次决定是正确的，否则他们面临的挑战会更多。\n\n我们在自信的同时也要保持清醒的自我认知，才能避免盲目自大。我曾经非常讨厌受到批评和质疑，并且总是设法规避这些批评。但现在我开始尝试听取这些意见，我会先设想这些批评是正确的，然后在这个基础上调整我的计划。做决定的过程充满了艰辛和痛苦，但也只有经历了这个过程才能将自信和自欺欺人区分开来。\n\n保持自信与自我认知之间的平衡可以让人免于傲气、避免与他人脱节。\n\n### 3.学会独立思考\n创业很难，因为培养原创性思维很难。这种思维在学校里面是学不到的，实际上学校培养的是一种相反的思维方式，所以只能靠我们自己来培养原创性思维。\n\n我们可以从第一性原理(first principles) 出发，从中想出新的点子，然后与人交流沟通，对这些想法进行改良，之后我们再用轻松快捷的方式进行实际测试。\n\n对创业者来说，失败是家常便饭，但我们一定要抱有必胜的信念，要不断尝试、不断试错，只有这样才能得到幸运之神的眷顾。在这个过程中，最宝贵的经验之一就是，我们要学会在绝境中找到一线生机。我们经历的越多就会越对此深信不疑。要知道勇气来自于多次失败后的坚持不懈。\n\n### 4.做一个好销售\n光有自信是不够的，我们还要具备说服他人的能力。就某种程度来说，所有职业的本质都是销售。你必须向客户、潜在职员、媒体、投资者等宣传兜售你的计划。想要说服他们，首先你的计划要有广阔的发展前景。对于个人而言，你要具备良好的沟通能力、一定的个人魅力以及强大的执行能力。\n\n具备良好的沟通能力十分重要，尤其是书面沟通。在这方面我的建议是：首先要保持思路清晰，然后就是尽量使用简洁明了的语言。\n\n而要做好“销售”最好的方式就是真诚，要对自己推销的产品抱有自信。销售其实无异于其他技能，我们可以通过可以练习提高销售技能。但是出于某些原因（比如人们可能不喜欢销售），很多人认为销售技能不可习得。\n\n做销售的另一个秘诀是:重要的事情要亲力亲为。在刚开始创业时，我非常乐意出差办事，这在很多人看来是不必要的，但是事事亲力亲为却给我带来了三次职业生涯的转折点，如果当时没有选择这样做，我可能会走上另一条道路。\n\n### 5.要有冒险精神\n大多数人往往都高估了风险低估了回报。冒险对我们来说也很重要，因为人不可能永远不犯错，我们需要不断试错，学习并快速适应。\n\n在职业生涯早期，人们往往更愿意冒险，因为那时你没有什么可失去的东西，但却可能得到很多。一旦一个人履行了自己的基本责任义务，就可以大胆冒险了。我篇幅可以先下小的赌注，如果赌输了会输掉1倍，但如果成功了，则可以赚到100倍。之后我们再沿着这个方向下更大的赌注。\n\n但是要注意不能一直待在舒适圈。在YC，我们从谷歌和脸书长期工作的创始人身上看到了这样一个问题：当人们习惯了舒适的生活、稳定的工作和无论做什么都会取得成功的名气时，就很难将这些置之于身后了（人们总是将他们的生活方式与下一年的工资相匹配）。即使他们真的离开了，也非常有可能再回来。与长期利益相比，短期诱惑和便利往往更具吸引力，也更符合人的天性。\n\n但当你摆脱了这些枯燥无味的工作，你可以跟随直觉将时间花在那些有趣的事情上。而想做到这一点，尽可能长时间地过着朴素灵动的生活是一个很好的方法。当然，任何选择背后都有相应的代价。\n\n### 6.保持专注\n专注可以让我们在工作中取得事半功倍的效果。磨刀不误砍柴工，在我认识的人中，那些花时间想明白了未来方向的人最后都得到了不错的结果。由此可见，做正确的事比长时间做事更重要。很多人都将自己的时间花在了无关紧要的事情上面。\n\n一旦你想明白了该做什么，就不要犹豫，快速行动起来去完成优先事项。毕竟成功人士就没有执行力弱的。\n\n### 7.努力工作\n通过运用自己的聪明才智或者勤奋努力，一个人可以达成工作领域里百分之九十的成就，能做到这一点已经很不错了，但是想要尽量做到完美，达成百分之九十九的成就，那就必须要兼顾聪明与勤奋，因为这一阶段你的竞争者往往是两者兼备的人。\n\n有付出才有收获，付出越多收获也就越大。努力工作可能会造成工作与生活失衡，我完全可以理解有的人选择去更好地平衡工作与生活，在工作中不那么拼命，但是拼命工作确实有很多好处，在多数情况下，努力工作会产生叠加效应，越是成功的人就越能成功。\n\n这通常很有趣。生活中最大的乐趣之一就是找到你的目标，并且有所建树，然后你会发现你在这件事上的影响力比你自己本身更重要。一位YC创始人表示：他在离开一家大公司后，尽力发挥了自己的最大影响力，此时他发现自己变得更快乐、更充实。\n\n为发挥出自己最大影响力而努力工作是值得庆祝的。我完全不能理解为什么在美国某些地区努力工作反而成了一件坏事，但我知道世界其他地区肯定不是这样的，那些地区的企业家表现出来的精力和干劲正在快速成为新的社会标杆。\n\n你必须想出一条平衡之策，在努力工作的同时，又不至于透支身体。对此，虽然人们的应对之策不尽相同，但有条几乎不会出错的黄金准则，那就是与相处愉快的人一起从事喜欢的工作。\n\n我认为，那些假装(在你生命中的某个时期)不用把精力放在工作上，就能平步青云的人，其实是在误人子弟。事实上，判断一个人能否笑到最后的关键因素之一就是工作耐力。\n\n另外，我认为刚入职场时就应该要努力工作。努力工作就像利滚利一样，越早开始，获利时间就越长。一般来说，人们身上背负的责任越少，就越容易施展身手。\n\n### 8.大胆一点\n在我看来，与轻松创业相比，人们多半会选择更具挑战性的事业。因为后者往往更激动人心，能带来更大的成就感和满足感。如果你在某个重大问题上取得了进展，就会有源源不断的人前来帮忙。志当存高远，不要害怕去做你真正想做的事情。\n\n如果别人都在创办 meme 公司，而唯独你想创办一家基因编辑公司那就去做吧，不要犹豫。\n\n追随你的好奇心。那些让你感到兴奋的事情，通常也适用于别人。\n\n### 9.足够坚定\n很多人都不知道，只要你足够坚持，世界就会以你的意志为转移。但大多数人甚至都不会去尝试，只单纯认为世界有其自身的运作规律。\n\n人的潜力是巨大的，只要敢想就能做成很多事。但大多数人都会怀疑自我、过早放弃，同时又不够努力，种种原因导致大多数人无法充分发挥自身潜能。\n\n询问自身诉求，你通常不能得偿所愿，而且被拒绝的滋味往往不好受。但若一旦成功，效果就会好得出奇。\n\n那些声称“我将永不言弃，直到梦想成真，不论前方有多少艰难险阻，我也会迎难而上”，并将其付诸行动的人，最后几乎总能获得成功。因为他们坚持了足够久，所以最终迎来了幸运之神的眷顾。\n\n在这方面，爱彼迎 (Airbnb)是我认为的行动标杆。业内流传着许多有关爱彼迎的逸闻趣事，虽然我并不推崇他们的做法(比如透支信用卡、每顿都吃一元店买的麦片、乐此不疲地与强劲的对手进行较量等等) 但是正因为他们足够坚持，最后终于时来运转。\n\n只有保持乐观才能足够坚定，而乐观这种性格特征是可以通过练习逐步提升的，而悲观者是很难成功的。\n\n### 10.保持强劲的市场竞争力\n大多数人都明白，企业竞争力越强，价值就越高。这点至关重要，而且也是显而易见的。这同样也适用于个人。如果你所从事的工作具有可替代性，那么你最终就会被薪资要求更低的人所取代。\n\n增强竞争力的最佳方式就是建立话语权。例如，你可以利用好个人关系，打造强大的个人品牌，或是在不同领域的交叉点建立起自己的个人优势。当然增强竞争力的方式还有很多但不论采取什么方式，关键是你必须要做到这一点。\n\n大多数人会模仿身边人的做法，但这种方式并不可取，如果一味模仿他人，那你还有什么竞争优势可言呢？\n\n### 11.建立人际网络\n出色的工作需要团队合作。打造既可密切合作又可轻松相处的优质人际网络是事业成功的必要因素。拥有优秀人才的人际网络的规模会决定你能成功的上限。\n\n建立人际网络的有效方法之一是尽可能多帮助他人。长期以来，这种行为方式给我带来了最佳职场机遇以及四项最佳投资中的三项。我总是惊讶与发生在自己身上的意外之喜，仅仅因为我十年前曾帮助过一位企业创始人。\n\n建立人际网络的另一个途径是拥有好的名声，不亏待每一个一起共事的人。要大方慷慨地与他人分享资源，这会给你带来10倍、100倍的回报。此外，要知人善用，让每个人都能充分施展自己的才华。\n\n我们既要尽力挖掘他人的潜力但是又不能逼得太紧，这容易让人感到精疲力尽。每个人都有各自擅长的领域，因此，我们要多看看自己的优点，不要总盯着缺点，要用优点来定义自身。面对缺点，我们要承认它，想办法弥补它，不要让缺点成为我们前进路上的阻碍。我常能在一些创业者口中听到这样的说法“我不能做A，因为我不擅长B”。这种思维方式让我十分吃惊。这反映出他们缺乏创造力。弥补弱点的最佳方式是聘请互补的团队成员，而不是雇佣那些跟你擅长相同事情的人。\n\n慧眼识珠挖掘未被发掘的人才是建立人际网络的有效途径。通过练习，我们能快速识别那些优质有动力、有创造力的人才。挖掘人才最简单的方式就是多社交，多与他人打交道并且与那些给你留下深刻印象的人保持联系。要记住一点，不要局限于他人过往的工作经验和当前成就，我们需要发掘那些有潜力且能在短时间激发潜能的人。\n\n每当遇到新人，我都会扪心自问“这个人有异于常人的能力吗？”对于渴求人才的人来说，这个问题很值得思考。\n\n建立人际网络的特例是找到你生命中的贵人，特别是在职业生涯早期。毫无疑问，能做到这点的最佳方法就是主动去帮助他人（记住，你必须在日后回报你的贵人！）\n\n最后，我们要结交那些积极向上且志同道合之人。\n\n### 12.资产决定财富\n小时候，我对经济的最大误解就是人们通过高薪发财致富。虽然也有一些特例，比如说娱乐圈的艺人，但从以往的福布斯榜单来看，几乎没有人是靠高薪荣登榜单的。\n\n拥有能迅速增值的东西才能真正发家致富。这些东西可以是商业资产、不动产、自然资源、知识产权等。但无论怎样，你需要实际拥有一些东西，而不是单靠出卖时间赚取工资，出卖时间赢来的财富只会呈慢速线性增长。\n\n让事物迅速增值的最佳方法就是大量制造人们想要的东西。\n\n### 13.要有内驱力\n大多数人主要都是靠外部驱动，他们做事情是为了让别人佩服。这种做法坏处颇多，但以下两点最为突出：\n\n首先这会导致你人云亦云，因循守旧。在工作中，你会过于在意他人的看法，这种在意程度可能已经远远超出了你的意识，并且这会阻碍你从事趣味性工作，即使你正在做这样的工作，也不过是在炒冷饭。\n\n其次，这会让你误判风险等级。从短期影响来看，你会将注意力主要放在和他人的竞争上，以确保不会在竞争游戏中落后。\n\n聪明人似乎更容易受到这种外驱力的影响。了解到了这一点可以帮助你摆脱这种影响，但帮助不大，我们必须要极其谨慎才能不至于掉入模仿他人的陷阱中。\n\n我认识的大多数成功人士都是靠自我驱动。他们做事情是为了让自己心悦诚服，因为他们觉得给世界带来改变是自己的责任。当你赚得盆满钵满并且拥有了较高的社会地位之后，金钱和名誉对你的吸引力开始逐渐消失，这时候内驱力就成为了唯一的动力，推动你向更高的地方攀登。\n\n这就是驱动力重要性的体现。驱动力是我了解他人时最先考察的点。我们很难用一套规则去定义正确的驱动力，但是当你遇到它时立刻就能有所体会。在这件事上，Jessica Livingston和Paul Graham是我认为的行动标杆。在YC创办的最初几年，人人都不看好它的发展，没有人认为YC能够成功。但是杰西卡和保罗很看好YC的发展，他们认为如果YC能够成功，将会对世界大有裨益，他们希望能够借此帮助到其他人，并且坚信这种新模式比现存的模式好。\n\n最终你会发现成功是在自己看重的领域里做出出色的成绩。向着自己热爱的方向越早出发就能走得越远，没有热爱之事的人是很难取得成就的。\n\n以上就是这篇博客的全文了，感谢也恭喜你看到这里，说明你是一个想要改变自己的人，很喜欢最近听到的一个道理，我总结在最后，与大家共勉！\n> “其实我今天说的这些建议，结论并不重要，因为我相信大家也不会因为今天听我说了一遍，明天你就会去实践，所以最重要的是，你要记得这些事情背后更深层的意义是什么。当你懂的了的事情背后的意义，日积月累，哪天你就可以顿悟，然后你就回去行动，最终带来一些改变 ” -\t冴羽",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1619930914211520514/NQ5LYd2q-slug_pic.jpg",
        "language": null,
        "viewNum": 93,
        "thumbNum": 8,
        "favourNum": 3,
        "commentNum": 1,
        "priority": 0,
        "userId": "1619930914211520514",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-02-21T10:55:55.000+00:00",
        "updateTime": "2023-03-12T11:44:59.000+00:00",
        "user": {
          "id": "1619930914211520514",
          "planetCode": "1012",
          "userName": "SnailRun",
          "userAvatar": "https://thirdwx.qlogo.cn/mmopen/vi_32/aRneVaen8XSWOILibfkW5SHicYZia2oDxA8zKUtnzLRVFbwiclEK8f80QMRk3kviawzL8gTWk4MgA0P0VeF1r0O0upg/132",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": null,
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": null,
          "direction": null,
          "goal": null,
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 1,
          "followNum": 1,
          "followStatus": null,
          "vipExpireTime": "2024-02-05T23:06:53.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-01-30T05:30:01.000+00:00",
          "updateTime": "2023-03-11T02:12:07.000+00:00"
        },
        "tags": [
          "文章",
          "B站",
          "视频",
          "ChatGPT"
        ],
        "fileList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": true,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1624991576214212610",
        "title": "编程导航会员特权",
        "description": "普通用户和会员的权限介绍",
        "content": "| 功能          | 普通用户               | 会员             |\n| ------------- | ---------------------- | ---------------- |\n| 查看普通帖子  | 只能查看前 5 页        | 查看全部         |\n| 查看精华帖子  | 可试看部分             | 查看全部         |\n| 查看会员帖子  | 可试看部分             | 查看全部         |\n| 发布帖子      | 等待排队审核           | 极速审核         |\n| 发布评论      | 等待排队审核           | 极速审核         |\n| 发布回复      | 等待排队审核           | 极速审核         |\n| 资源 - 发布   | 等待排队审核           | 极速审核         |\n| 资源 - 查看   | ❌ 无法查看内容         | ✅ 查看全部       |\n| 求资源 - 发布 | ❌                      | ✅ 专人帮忙找资源 |\n| 求资源 - 查看 | ❌ 无法查看评论区的资源 | ✅ 查看全部       |\n| 问答 - 发布   | ❌                      | ✅ 专人帮忙回答   |\n| 问答 - 查看   | ❌ 无法查看评论区回答   | ✅ 查看全部       |\n| 简历 - 发布   | ❌                      | ✅ 专人帮忙修改   |\n| 简历 - 查看   | ❌ 无法查看评论区建议   | ✅ 查看全部       |\n| 面试题 - 发布 | 等待排队审核           | 极速审核         |\n| 面试题 - 查看 | ❌ 无法查看评论区题解   | ✅ 查看全部       |\n| 直播 - 查看   | ❌ 无法查看内容         | ✅ 查看全部       |\n| 笔记 - 发布   | 等待排队审核           | 极速审核         |\n| 笔记 - 查看   | ❌ 只能查看前 5 页      | ✅ 查看全部       |\n| 随笔 - 发布   | 等待排队审核           | 极速审核         |\n| 随笔 - 查看   | ❌ 只能查看前 5 页      | ✅ 查看全部       |\n| 文章 - 发布   | 等待排队审核           | 极速审核         |\n| 文章 - 查看   | ❌ 只能查看前 5 页      | ✅ 查看全部       |\n| 鱼币兑奖      | ❌                      | ✅                |\n\n\n",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1601072287388278786/3PtezNAW-企业微信20230213-123829@2x (1).png",
        "language": null,
        "viewNum": 1993,
        "thumbNum": 24,
        "favourNum": 1,
        "commentNum": 9,
        "priority": 999,
        "userId": "1601072287388278786",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-02-13T04:39:17.000+00:00",
        "updateTime": "2023-03-12T09:28:04.000+00:00",
        "user": {
          "id": "1601072287388278786",
          "planetCode": "1",
          "userName": "程序员鱼皮",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1601072287388278786/9vqTr3HM-WechatIMG1287.jpeg",
          "gender": 1,
          "userProfile": "这个网站的老大",
          "userRole": "admin",
          "interests": [
            "C++",
            "Java",
            "Python",
            "算法"
          ],
          "place": "上海",
          "birthday": "1998-11-03",
          "school": "东华大学",
          "major": "网络工程",
          "education": null,
          "graduationYear": 2020,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": 2,
          "direction": "后端",
          "goal": null,
          "github": "https://github.com/liyupi",
          "blog": "https://yupi.icu",
          "score": 410,
          "coin": 170,
          "followeeNum": 260,
          "followNum": 5,
          "followStatus": null,
          "vipExpireTime": "2025-12-13T05:00:02.000+00:00",
          "lastLoginTime": null,
          "createTime": "2022-12-09T04:32:33.000+00:00",
          "updateTime": "2023-03-12T07:37:00.000+00:00"
        },
        "tags": [
          "文章"
        ],
        "fileList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": true,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1620297481155788801",
        "title": "编程导航积分规则",
        "description": "了解积分的作用、获取方式等",
        "content": "好的编程交流氛围需要大家的共同努力！⛽️️\n\n为鼓励大家积极交流和分享，编程导航设定了积分系统，积分可用于升级和获取奖励。\n\n\n## 获取积分\n\n可以通过如下途径获取积分：\n\n1）[做任务](/prize/task)\n\n2）[积极分享内容](/add)\n\n- 帖子被精选，积分 +10\n- 评论被精选，积分 +5\n\n3）参与活动\n\n## 等级特权\n\n积分决定了用户的等级，升级规则和特权如下：\n\n| 等级 | 需要积分 | 特权     |\n| ---- | -------- | -------- |\n| 1    | 0        | 无       |\n| 2    | 30       | 无       |\n| 3    | 100      | 无     |\n| 4    | 200      | 无 |\n| 5    | 500      | 红包 \uD83E\uDDE7   |\n| 6    | 1000     | 红包 \uD83E\uDDE7\uD83E\uDDE7  |\n| 7    | 2000     | 红包 \uD83E\uDDE7\uD83E\uDDE7\uD83E\uDDE7 |\n| 8    | 5000     | 未开放     |\n| 9    | 10000    | 未开放     |\n| 10   | 30000    | 未开放     |\n\n> 以上奖励请联系微信：yupi1085 领取\n\n\n注意，积分规则可能会调整，请以本文档最新内容为主。\n",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1601072287388278786/LMz3fWrZ-score.png",
        "language": null,
        "viewNum": 855,
        "thumbNum": 9,
        "favourNum": 0,
        "commentNum": 8,
        "priority": 0,
        "userId": "1601072287388278786",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-01-31T05:46:38.000+00:00",
        "updateTime": "2023-03-12T12:03:55.000+00:00",
        "user": {
          "id": "1601072287388278786",
          "planetCode": "1",
          "userName": "程序员鱼皮",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1601072287388278786/9vqTr3HM-WechatIMG1287.jpeg",
          "gender": 1,
          "userProfile": "这个网站的老大",
          "userRole": "admin",
          "interests": [
            "C++",
            "Java",
            "Python",
            "算法"
          ],
          "place": "上海",
          "birthday": "1998-11-03",
          "school": "东华大学",
          "major": "网络工程",
          "education": null,
          "graduationYear": 2020,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": 2,
          "direction": "后端",
          "goal": null,
          "github": "https://github.com/liyupi",
          "blog": "https://yupi.icu",
          "score": 410,
          "coin": 170,
          "followeeNum": 260,
          "followNum": 5,
          "followStatus": null,
          "vipExpireTime": "2025-12-13T05:00:02.000+00:00",
          "lastLoginTime": null,
          "createTime": "2022-12-09T04:32:33.000+00:00",
          "updateTime": "2023-03-12T07:37:00.000+00:00"
        },
        "tags": [
          "文章"
        ],
        "fileList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1620281129347076098",
        "title": "鱼皮的自我介绍",
        "description": null,
        "content": "大家好，我是鱼皮，首先感谢朋友们加入编程导航！这是一个有温度的编程学习交流平台，希望大家在这里都能畅所欲言、认识更多朋友、有所进步。\n\n首先由我来给大家做一个自我介绍。\n\n我是一名 24 岁的程序员，目前在大厂从事应用开发工作，技术栈以 Java、React 为主，也出于兴趣自学过小程序、移动应用、大数据、区块链、产品、运营等各方向的内容。平时热爱动手做项目、更热爱分享，因此有幸成为了一名知识分享博主并在一年内全网收获了上百万个粉丝！\n\n分享一下我的个人经历：\n\n> 由于内容很多，采用时间线的形式\n\n- 2016 年 9 月：考入东华大学计算机学院（211），担任班长、加入校学生会\n- 2016 年 10 月：加入学校网站建设工作室，开始自学前端技术\n- 2017 年 1 月：跟名校同学交流后，备受打击，决定发奋自学超越他们！寒假期间 **自学** 了 Java 和数据库，之后持续学习前端和 Java 后端技术\n- 2017 年 4 月：作为负责人，成功申报 **国家级创新创业项目** ，**自学** Python 带队开发\n- 2017 年 5 月：**主动** 加入副院长的项目团队，**自学** C# 参与开发\n- 2017 年 7 月：利用暑假 **自学** Node.js、网络安全等技术\n- 2017 年 9 月：成为院学生会新媒体部长、校乒乓社团部长、校网站建设工作室 **负责人**\n- 2018 年 1 月：和学长一起参与计算机应用能力竞赛，负责前端开发，最后虽然只拿了三等奖，但受益匪浅\n- 2018 年 6 月：参与人生第一份实习，是一家金融科技公司，每天 **坐高铁** 上下班。当时投大厂没人鸟，面试几家前端又全挂了，只能选择了一份 Java 后端方向的实习，也因此确立了未来的发展目标，开始疯狂 **自学** Java 后端技术，比如常见框架、缓存、队列、搜索引擎、并发等。\n- 2018 年 7 月：加入学院的安全实验室，跟导师研究区块链技术，并于一年后 **出版教材**《区块链智能合约技术与应用》（个人编写章节超过 50%）\n- 2018 年 12 月：主动投递并找到第二份实习，**字节跳动** 的后端开发（PHP / Golang），时长近半年，最终因为纠结读研还是就业提前结束。\n- 2019 年 4 月：**连续三届** 在学院给学弟妹们开课讲编程（每次半年，课题分别为网站开发、数据持久化、区块链）\n- 2019 年 5 月：**带队** 参与三创赛，凭借原创的拼团购物 APP 荣获 **上海市级二等奖**\n- 2019 年 6 月：参与第三份实习，**腾讯广告** 的应用开发，技术栈以 Java + React 为主，最终以组内 **第一名** 的成绩转正（同组内清北复交大佬不在少数），拿到 **SSP 最高级别** 的 offer！\n- 2019 年 9 月：综合考量后，**放弃保研名额**，决定在职场好好打拼，并且整个大四几乎都在腾讯实习，提前积累经验。\n- 2019 年 11 月：参与挑战杯竞赛，作为技术负责人和答辩人，荣获 **国家级二等奖** 和 **上海市特等奖**\n- 2020 年 2 月：开设抖音账号【程序员鱼皮】，用视频分享面试题，主要目的是帮助自己复习（所以做了 100 多个视频只有 100 多个粉丝）\n- 2020 年 6 月：顺利毕业，荣获 **上海市优秀毕业生** 、东华大学年度人物等多项荣誉\n- 2020 年 9 月：积分落户上海\n- 2020 年 11 月：游戏打累了，开设微信公众号【程序员鱼皮】，一年的时间，粉丝数突破 20 万\n- 2020 年 12 月：自主开发上线网站【编程导航】，一年的时间，用户数近 10 万\n- 2021 年 2 月：开设 B 站账号【程序员鱼皮】，一年的时间，粉丝数近 30 万\n- 2021 年 3 月：成为 **腾讯云开发高级布道师** ，分享和普及云开发技术的使用\n- 2021 年 5 月：带队参加公司内部的《云开发技术竞赛》，荣获 **冠军**\n- 2021 年 6 月：荣获公司 **OutStanding 五星员工**（下半年四星，tnnd 退步了）\n- 2021 年 11 月：参与阿里云大使推广活动，带 7000 多名小伙伴领取了免费的服务器，超级霸榜，以至于阿里奖励池子都干了。。。\n- 2021 年 12 月：自主 开发上线网站【面试鸭】，目前网站因攻击过多，暂时战术下线。\n- 2022 年 1 月 1 日：一个小县城郊区的孩子，凭自己的努力赚到了人生的第一个 **百万** ，并给父母买了两部 iPhone 手机（虽然后来被他们退了）\n- 2022 年 2 月：开设 [编程导航知识星球](https://yupi.icu)，希望在工作之余，维护好属于自己的小圈子 ( ▽ )\n- 2023 年 1 月：已坚持运营 [编程导航知识星球](https://yupi.icu) 一整年，星球人数超过 1.5w，多次霸榜星球活跃 TOP 1！感谢大家的支持~\n\n不知道朋友们有没有发现，我在介绍中多次提到了 “自学”、“主动”、“自主” 等词汇。现在看来的确是这样，只有自学主动、积极乐观，才能持续学习、抓住机会、获得成功。\n\n我也不是一开始就有能力进大厂的，从最开始投递简历被人置之不理，再到最后成功拿到顶级大厂 offer，真的是通过自己一步步的努力才争取来的，所以我绝对相信天道酬勤，努力总比不努力的好。\n\n相信自己有能力，那么你就真的会有！\n\n我的 GitHub：https://github.com/liyupi\n\n最后祝朋友们在编程导航学的愉快、玩的开心，收获伙伴与成长、实现自己的目标！",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1601072287388278786/AQZaEd9M-WechatIMG2277.jpeg",
        "language": null,
        "viewNum": 100,
        "thumbNum": 8,
        "favourNum": 1,
        "commentNum": 0,
        "priority": 0,
        "userId": "1601072287388278786",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-01-31T04:41:39.000+00:00",
        "updateTime": "2023-03-11T08:13:56.000+00:00",
        "user": {
          "id": "1601072287388278786",
          "planetCode": "1",
          "userName": "程序员鱼皮",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1601072287388278786/9vqTr3HM-WechatIMG1287.jpeg",
          "gender": 1,
          "userProfile": "这个网站的老大",
          "userRole": "admin",
          "interests": [
            "C++",
            "Java",
            "Python",
            "算法"
          ],
          "place": "上海",
          "birthday": "1998-11-03",
          "school": "东华大学",
          "major": "网络工程",
          "education": null,
          "graduationYear": 2020,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": 2,
          "direction": "后端",
          "goal": null,
          "github": "https://github.com/liyupi",
          "blog": "https://yupi.icu",
          "score": 410,
          "coin": 170,
          "followeeNum": 260,
          "followNum": 5,
          "followStatus": null,
          "vipExpireTime": "2025-12-13T05:00:02.000+00:00",
          "lastLoginTime": null,
          "createTime": "2022-12-09T04:32:33.000+00:00",
          "updateTime": "2023-03-12T07:37:00.000+00:00"
        },
        "tags": [
          "文章",
          "自我介绍"
        ],
        "fileList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": true,
        "hasFavour": true,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1609197574307184642",
        "title": "【并发编程】自定义简单线程池",
        "description": "通过自定义的简单线程池，对Java的ThreadPool有一个更进一步的理解",
        "content": "\n## 优质博文\n\n[更好的使用 JAVA 线程池](https://my.oschina.net/andylucc/blog/648127)\n\n[深入理解Java线程池：ThreadPoolExecutor](http://www.ideabuffer.cn/2017/04/04/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9AThreadPoolExecutor/)\n\n[Java线程池实现原理及其在美团业务中的实践](https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html)\n\n## 1、概念图\n\n核心部分：\n\n- 阻塞队列`BlockingQueue`：暂存线程池中无法处理的任务\n- 线程池`ThreadPool`：自定义的线程池，内部最多包含`coreSize`个工作线程执行任务\n- 工作线程`WorkerThread`：执行传递过来的任务\n- 拒绝策略`Rejectpolicy`：当阻塞队列已满时采用指定的策略拒绝任务\n\n![image-20221119130356097](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/10033/image-20221119130356097.png)\n\n## 2、流程分析\n\n根据上面的概念图，进一步模拟一遍整个线程池执行的流程：\n\n1. **初始化线程池**，指定线程池的参数如**核心线程数、阻塞队列容量、超时时间、拒绝策略**;\n2. 并发生产**任务压入线程池**执行；\n   1. 工作线程数**未达到**设定的核心线程数。**新建工作线程**执行任务，并将工作线程加入到线程池中的**线程集合**中；\n   2. 工作线程数**达到了**设定的核心线程数。**尝试往阻塞队列中暂存任务**，当阻塞队列**已满**无法添加时，采用指定的**拒绝策略**对任务进行拒绝。\n3. 工作线程执行完当前任务时，**循环从阻塞队列中获取任务**并执行直到消费完阻塞队列中的任务；\n4. 当无任务时，将工作**线程回收**销毁。\n\n## 3、设计思路及实现\n\n整体的设计思路应该由广到细，整体到局部。前面的概念图以及流程分析其实就算是一个整体的设计了，接下来便是局部的设计了。首先先列举一下需要的部分，分别为：\n\n- 线程池\n- 工作线程\n- 阻塞队列\n- 拒绝策略\n\n结合上面一二点的描述我们可以得出线程池中用到了工作线程和阻塞队列，而当阻塞队列满时需要根据拒绝策略进行任务拒绝，因此我们采取自下而上的方式逐一设计需要的几大主体。\n\n### 3.1、拒绝策略\n\n---\n\n其实拒绝策略就是一段逻辑，通过调用者告知使用哪种方式进行任务拒绝。根据`OOP思想`，这一段逻辑我们可以封装成不同的方法，通过传入不同的标识选用不同的方法即可。这里使用了`Java1.8`出现的函数式编程进行设计，将这一个逻辑封装成一个函数式接口，调用者可直接使用Lambda表达式指定需要的拒绝策略，也可将逻辑封装成一个枚举类，直接传入对应的方法即可，这符合设计模式中的开闭原则，可维护性更高。\n\n```java\n@FunctionalInterface\npublic interface RejectPolicy<T> {\n    /**\n     * @description 拒绝策略中的拒绝方法，可自定义设置适合的拒绝策略\n     * @author xbaozi\n     * @date 2022/11/18 22:34\n     * @param queue 阻塞队列\n     * @param task  需要拒绝的任务\n     **/\n    void reject(BlockingQueue<T> queue, T task);\n}\n```\n\n### 3.2、阻塞队列\n\n---\n\n在该阻塞队列中采取了`公平的FIFO形式`，避免任务一直得不到消费出现**饿死情况**，因此内部需要维护一个**双向队列**。出于内存层面考虑，我们需要维护一个队列**最大容量**变量，用于判断队列是否已满，避免`OOM问题`出现。同时由于阻塞队列为多线程下的共享资源，我们需要对其上锁保证在并发消费下的原子性。最后为了阻塞队列的拓展性，队列中存放的内容采取泛型设计。\n\n- **双向队列Deque**：Java内置的双向队列接口，实现类采用ArrayDeque，在大部分情况下会比LinkList性能要好一点；\n- **最大容量capacity**：基本整形变量，用于判断队列是否已满；\n- **锁对象LOCK**：采用可重入锁ReentrantLock实现，并分别设置消费者条件变量与生产者条件变量，对队列为空与队列已满两种情况进行隔离。\n\n---\n\n在变量设计完成之后，我们还需要对队列中的**方法**进行设计。显而易见的是队列的**核心任务为存和取**，重点的是怎么存和取。比较容易想到的是**超时与无超时限制**的存取，但是这样子的话并没有用到我们的拒绝策略，因此应该还有一个方法是**尝试将任务存入队列**中，当队列满时采用指定的拒绝策略即可。\n\n- `void put(T task)`：添加任务，这是一个**阻塞添加无超时**的方法，即这个方式在队列已满时会一直等待直到队列中出现闲余空间；\n- `boolean put(T task, long timeout, TimeUnit timeUnit)`：带超时限制的添加任务，当等待了指定时间后队列仍然无空间时，则会放弃当前任务退出等待；\n- `void tryPut(T task, RejectPolicy<T> rejectPolicy)`：**尝试添加任务**，如果任务队列满了会根据传入的**拒绝策略**对任务进行处理；\n- `T take()`：获取任务，这是一个**阻塞获取无超时**的方法，即队列为空时会一直等待直到队列中出现任务；\n- `T take(long timeout, TimeUnit unit)`：带**超时时间限制**返回获取到的任务，当等待了指定时间后队列仍然为空时，则会放弃获取退出等待。\n\n```java\n/**\n * @author xbaozi\n * @version 1.0\n * @classname BlockingQueue\n * @date 2022-11-17  16:35\n * @description 阻塞队列，使用泛型增加拓展性\n */\n@Slf4j(topic = \"xbaoziplus.BlockingQueue\")\npublic class BlockingQueue<T> {\n    // 任务队列，使用双向链表尾进头出\n    private final Deque<T> TASK_QUEUE = new ArrayDeque<>();\n\n    // 队列最大容量\n    private int capacity;\n\n    // 锁对象\n    private final ReentrantLock LOCK = new ReentrantLock();\n\n    // 生产者条件变量，当队列中满了的话生产者线程需要进入该condition进行等待\n    private final Condition PRODUCER_WAIT_CONDITION = LOCK.newCondition();\n\n    // 消费者条件变量，当队列中为空时消费者线程需要进入该condition进行等待\n    private final Condition CONSUMER_WAIT_CONDITION = LOCK.newCondition();\n\n    // 有参构造器，初始化队列最大容量\n    public BlockingQueue(int capacity) {\n        this.capacity = capacity;\n    }\n\n    /**\n     * @param task 生产者产生的任务\n     * @description 添加任务，这是一个阻塞添加的方法\n     * @author xbaozi\n     * @date 2022/11/17 16:57\n     **/\n    public void put(T task) {\n        // 因为获取大小和添加任务不是原子操作，因此需要上锁保证原子性\n        LOCK.lock();\n        try {\n            // 自旋判断队列是否已满，避免虚假唤醒\n            while (TASK_QUEUE.size() >= capacity) {\n                try {\n                    log.error(\"队列已满，生产者等待将任务加入任务队列中……\");\n                    // 进入生产者条件变量中等待\n                    PRODUCER_WAIT_CONDITION.await();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n            // 任务队列出现闲余空间时，将任务采用尾插法添加至任务队列中\n            log.info(\"任务队列存在闲余空间，{}加入队列\", task);\n            TASK_QUEUE.addLast(task);\n            // 唤醒消费者条件变量中线程，提示队列不为空，可以进行任务消费移除\n            CONSUMER_WAIT_CONDITION.signal();\n        } finally {\n            LOCK.unlock();\n        }\n    }\n\n    /**\n     * @param task     生产者产生的任务\n     * @param timeout  超时时间\n     * @param timeUnit 时间单位\n     * @description 带超时限制的添加任务\n     * @author xbaozi\n     * @date 2022/11/18 21:38\n     **/\n    public boolean put(T task, long timeout, TimeUnit timeUnit) {\n        LOCK.lock();\n        try {\n            // 将超时时间转换成纳秒\n            long nanos = timeUnit.toNanos(timeout);\n            while (TASK_QUEUE.size() >= capacity) {\n                try {\n                    // 判断是否超时\n                    if (nanos <= 0) {\n                        // 超时返回失败标识\n                        log.error(\"添加任务{}超时\", task);\n                        return false;\n                    }\n                    // 进入生产者条件变量中等待nanos秒或等待被唤醒\n                    nanos = PRODUCER_WAIT_CONDITION.awaitNanos(nanos);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n            log.info(\"不超时，{}加入任务队列成功\", task);\n            // 尾插法插入任务\n            TASK_QUEUE.addLast(task);\n            // 唤醒消费者条件变量中线程，提示队列不为空，可以进行任务消费移除\n            CONSUMER_WAIT_CONDITION.signal();\n            return true;\n        } finally {\n            LOCK.unlock();\n        }\n    }\n\n    /**\n     * @description 添加任务，如果任务队列满了会根据传入的拒绝策略对任务进行处理\n     * @author xbaozi\n     * @date 2022/11/18 23:15\n     * @param task  任务\n     * @param rejectPolicy  拒绝策略\n     **/\n    public void tryPut(T task, RejectPolicy<T> rejectPolicy) {\n        LOCK.lock();\n        try {\n            // 判断任务队列是否已满\n            if (TASK_QUEUE.size() >= capacity) {\n                // 任务队列已满，采取设定的拒绝策略进行处理\n                rejectPolicy.reject(this, task);\n            } else {\n                // 任务队列未满，添加至任务队列中\n                log.info(\"{}加入任务队列成功\", task);\n                TASK_QUEUE.addLast(task);\n                // 唤醒消费者条件变量中线程，提示队列不为空，可以进行任务消费移除\n                CONSUMER_WAIT_CONDITION.signal();\n            }\n        } finally {\n            LOCK.unlock();\n        }\n    }\n\n    /**\n     * @return T    返回获取到的任务\n     * @description 获取任务，这是一个阻塞获取的方法\n     * @author xbaozi\n     * @date 2022/11/17 17:05\n     **/\n    public T take() {\n        // 因为判断队列是否为空和弹出任务不是原子操作，因此需要上锁保证原子性\n        LOCK.lock();\n        try {\n            // 自旋判断队列是否为空，避免虚假唤醒\n            while (TASK_QUEUE.isEmpty()) {\n                try {\n                    log.error(\"队列为空，消费者等待任务到来进行消费……\");\n                    // 进入消费者条件变量中等待\n                    CONSUMER_WAIT_CONDITION.await();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n            // 任务队列中产生了新任务时，从队列头部获取\n            T task = TASK_QUEUE.removeFirst();\n            log.info(\"队列中有任务{}取出消费\", task);\n            // 唤醒生产者条件变量中线程，提示队列已出现闲余空间，可以进行任务生产添加\n            PRODUCER_WAIT_CONDITION.signal();\n            // 返回任务\n            return task;\n        } finally {\n            LOCK.unlock();\n        }\n    }\n\n    /**\n     * @description 带超时时间限制返回获取到的任务\n     * @author xbaozi\n     * @date 2022/11/18 22:40\n     * @param timeout   超时时间\n     * @param unit      超时时间单位\n     **/\n    public T take(long timeout, TimeUnit unit) {\n        LOCK.lock();\n        try {\n            long nanos = unit.toNanos(timeout);\n            // 判断任务队列中是否有任务可拿\n            while (TASK_QUEUE.isEmpty()) {\n                if (nanos <= 0) {\n                    return null;\n                }\n                try {\n                    log.error(\"队列为空，消费者等待任务到来进行消费……\");\n                    // 进入消费者条件变量中等待\n                    nanos = CONSUMER_WAIT_CONDITION.awaitNanos(nanos);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n            // 任务队列中有任务可拿时，从队列头部获取任务\n            T task = TASK_QUEUE.removeFirst();\n            log.info(\"队列中有任务{}取出消费\", task);\n            // 唤醒生产者条件变量中线程，提示队列已出现闲余空间，可以进行任务生产添加\n            PRODUCER_WAIT_CONDITION.signal();\n            // 返回任务\n            return task;\n\n        } finally {\n            LOCK.unlock();\n        }\n    }\n\n    /**\n     * @description 获取阻塞队列中的任务数\n     * @author xbaozi\n     * @date 2022/11/18 22:19\n     **/\n    public int size() {\n        LOCK.lock();\n        try {\n            return TASK_QUEUE.size();\n        } finally {\n            LOCK.unlock();\n        }\n    }\n}\n```\n\n### 3.3、工作线程\n\n---\n\n你可能在想着为什么还要自定义一个工作线程，直接用Thread不行吗？其实还真不行.\n\n因为在工作线程中我们需要对task任务进行消费，而run方法并不支持传参，因此我们需要自定义一个**WorkerThread继承Thread**，并拓展一个成员变量task，通过构造器传参实现对任务的消费。\n\n另外需要注意的是这个工作线程在设计的时候将其设定为线程池的内部类，因此代码在线程池中再一起贴出来\n\n### 3.4、线程池\n\n---\n\n我们先根据需求来判断我们需要哪些成员变量。\n\n首先我们需要核心线程来工作执行消费任务，因此需要一个**核心线程数**变量，并且需要一个**容纳线程的集合**存放工作线程；\n\n其次我们在工作线程达到核心线程数时，需要将任务暂时存入阻塞队列中，因此需要一个**阻塞队列**的变量，值得注意的是在构造器初始化时应该传入队列容量在构造器中进行实例化，而不是传入一个阻塞队列对象，提供使用而不暴露实现；\n\n紧接着的就是**超时时间**了，也可以将其忽略在执行方法时将其当做参数进行方法传参，这里放在成员变量中便于统一管理；\n\n最后便是**拒绝策略**，在初始化线程池时就应该指定线程池的拒绝策略，在阻塞队列满时对任务进行拒绝。\n\n```java\n@Slf4j(topic = \"xbaoziplus.MyThreadPool\")\npublic class ThreadPool {\n    // 任务阻塞队列\n    private final BlockingQueue<Runnable> BLOCKING_QUEUE;\n\n    // 线程集合\n    private final Set<WorkerThread> workers = new HashSet<>();\n\n    // 核心线程数\n    private int coreSize;\n\n    // 获取任务的超时时间\n    private long timeout;\n\n    // 获取任务超时时间的时间单位\n    private TimeUnit unit;\n\n    // 拒绝策略\n    RejectPolicy<Runnable> rejectPolicy;\n\n    public ThreadPool(int queueCapacity, int coreSize, int timeout, TimeUnit unit, RejectPolicy<Runnable> rejectPolicy) {\n        this.BLOCKING_QUEUE = new BlockingQueue<>(queueCapacity);\n        this.coreSize = coreSize;\n        this.timeout = timeout;\n        this.unit = unit;\n        this.rejectPolicy = rejectPolicy;\n    }\n\n    /**\n     * @param task 需要执行的任务\n     * @description 线程池接收任务执行\n     * @author xbaozi\n     * @date 2022/11/17 17:52\n     **/\n    public void execute(Runnable task) {\n        synchronized (workers) {\n            // 判断工作线程数是否达到了核心线程数\n            if (workers.size() < coreSize) {\n                // 工作线程数未达到核心线程数，新建一个工作线程\n                WorkerThread workerThread = new WorkerThread(task, workers.size() + \"号工作线程\");\n                log.info(\"未达到核心线程数，新建工作线程{}\", workerThread.getName());\n                // 将工作线程添加到线程集合中\n                workers.add(workerThread);\n                // 启动线程执行任务\n                workerThread.start();\n            } else {\n                // 工作线程已达到核心线程数，将任务放入任务队列中暂存\n                // log.info(\"工作线程已达到核心线程数，{}进入任务队列暂存\", task);\n                // 无超时阻塞添加任务\n                // BLOCKING_QUEUE.put(task);\n                // 设置超时时间添加任务\n                // BLOCKING_QUEUE.put(task, timeout, unit);\n                // 尝试添加任务，任务添加失败时选择自定义的拒绝策略\n                log.info(\"工作线程已达到核心线程数，尝试添加任务{}到任务队列中暂存\", task);\n                BLOCKING_QUEUE.tryPut(task, rejectPolicy);\n            }\n        }\n    }\n\n    /**\n     * @author xbaozi\n     * @description 线程池中工作线程\n     * @date 2022/11/17 17:26\n     **/\n    //@Slf4j(topic = \"xbaoziplus.MyThreadPool.WorkerThread\")\n    class WorkerThread extends Thread {\n        // 需要执行的任务\n        private Runnable task;\n\n        public WorkerThread(Runnable task, String name) {\n            super(name);\n            this.task = task;\n        }\n\n        @Override\n        public void run() {\n            // 自旋判断当前任务是否为空，不为空执行任务，为空时获取下一个任务接着执行\n            // while (task != null || (task = BLOCKING_QUEUE.take()) != null) {  // 无超时限制的等待获取任务\n            // 有超时限制的等待获取任务\n            while (task != null || (task = BLOCKING_QUEUE.take(timeout, unit)) != null) {\n                try {\n                    // 执行任务\n                    log.info(\"{}正在执行……\", task);\n                    task.run();\n                } catch (Exception e) {\n                    e.printStackTrace();\n                } finally {\n                    // 不能在这里赋值task = BLOCKING_QUEUE.take()，否则容易产生线程饥饿\n                    task = null;\n                }\n            }\n            // 执行完毕时，将当前工作线程移除，实现线程销毁效果\n            synchronized (workers) {\n                log.info(\"任务执行完毕，线程{}已销毁\", this.getName());\n                workers.remove(this);\n            }\n        }\n    }\n}\n```\n\n## 4、测试线程池\n\n这里并没有封装一部分的拒绝策略给调用者进行选择，而是完全由调用者编写拒绝策略。这里一共列举了五种拒绝策略，分别为：\n\n- 死等，直到阻塞队列出现空间或工作线程空余；\n- 超时等待，等待一定时间后自行结束；\n- 直接放弃，当阻塞队列已满时直接对后续的任务进行放弃；\n- 抛异常，当阻塞队列已满时抛出异常提示调用者；\n- 自行执行任务，让调用者线程自行执行多出来的任务。\n\n```java\n@Slf4j(topic = \"test.TestPool\")\npublic class TestPool {\n    public static void main(String[] args) {\n        // 新建线程池\n        ThreadPool pool = new ThreadPool(2, 2, 2, TimeUnit.SECONDS, (queue, task) -> {\n            // 1. 死等\n            //queue.put(task);\n            // 2) 超时等待\n            //queue.put(task, 1500, TimeUnit.MILLISECONDS);\n            // 3) 直接放弃\n            log.debug(\"任务队列已满，放弃任务{}\", task);\n            // 4) 抛出异常\n            //try {\n            //    throw new RuntimeException(\"任务执行失败 \" + task);\n            //} catch (RuntimeException e) {\n            //    log.debug(\"任务队列已满，{}\", e.getMessage());\n            //}\n            // 5) 自行执行任务\n            // task.run();\n        });\n        // 模拟五个线程生产任务压入线程池中执行\n        for (int i = 0; i < 5; i++) {\n            int index = i;\n            pool.execute(() -> {\n                try {\n                    // 模拟任务执行需要1s\n                    Thread.sleep(1000L);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                log.info(\"任务{}执行完毕\", index);\n            });\n        }\n    }\n}\n```\n\n![image-20221119154527570](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/10033/image-20221119154527570.png)\n",
        "category": "文章",
        "cover": null,
        "language": null,
        "viewNum": 5,
        "thumbNum": 0,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1609195689525379074",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": "1608440217629360130",
        "reviewTime": "2023-02-09T22:11:58.000+00:00",
        "createTime": "2022-12-31T14:39:33.000+00:00",
        "updateTime": "2023-03-03T02:13:17.000+00:00",
        "user": {
          "id": "1609195689525379074",
          "planetCode": "10033",
          "userName": "爱吃鱼蛋",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1609195689525379074/x3UPNmor-avatar.jpg",
          "gender": 1,
          "userProfile": "喜欢吃鱼蛋",
          "userRole": "vip",
          "interests": [],
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": null,
          "direction": "Java",
          "goal": "中大厂",
          "github": null,
          "blog": null,
          "score": 40,
          "coin": 20,
          "followeeNum": 0,
          "followNum": 0,
          "followStatus": null,
          "vipExpireTime": "2024-02-19T22:57:04.000+00:00",
          "lastLoginTime": null,
          "createTime": "2022-12-31T14:32:04.000+00:00",
          "updateTime": "2023-03-11T03:48:38.000+00:00"
        },
        "tags": [
          "文章",
          "高并发",
          "Java"
        ],
        "fileList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      }
    ],
    "total": "8",
    "size": "10",
    "current": "1",
    "orders": [],
    "optimizeCountSql": true,
    "searchCount": true,
    "countId": null,
    "maxLimit": null,
    "pages": "1"
  },
  "message": "ok"
}